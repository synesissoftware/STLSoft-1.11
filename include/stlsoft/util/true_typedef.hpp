/* /////////////////////////////////////////////////////////////////////////
 * File:    stlsoft/util/true_typedef.hpp
 *
 * Purpose: Contains the true_typedef class template.
 *
 * Created: 16th January 2002
 * Updated: 10th October 2024
 *
 * Home:    http://stlsoft.org/
 *
 * Copyright (c) 2019-2024, Matthew Wilson and Synesis Information Systems
 * Copyright (c) 2002-2019, Matthew Wilson and Synesis Software
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * - Neither the name(s) of Matthew Wilson and Synesis Information Systems
 *   nor the names of any contributors may be used to endorse or promote
 *   products derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ////////////////////////////////////////////////////////////////////// */


/** \file stlsoft/util/true_typedef.hpp
 *
 * \brief [C++] Definition of the stlsoft::true_typedef class template
 *   (\ref group__library__Utility "Utility" Library).
 */

#ifndef STLSOFT_INCL_STLSOFT_UTIL_HPP_TRUE_TYPEDEF
#define STLSOFT_INCL_STLSOFT_UTIL_HPP_TRUE_TYPEDEF

#ifndef STLSOFT_DOCUMENTATION_SKIP_SECTION
# define STLSOFT_VER_STLSOFT_UTIL_HPP_TRUE_TYPEDEF_MAJOR    4
# define STLSOFT_VER_STLSOFT_UTIL_HPP_TRUE_TYPEDEF_MINOR    1
# define STLSOFT_VER_STLSOFT_UTIL_HPP_TRUE_TYPEDEF_REVISION 3
# define STLSOFT_VER_STLSOFT_UTIL_HPP_TRUE_TYPEDEF_EDIT     94
#endif /* !STLSOFT_DOCUMENTATION_SKIP_SECTION */


/* /////////////////////////////////////////////////////////////////////////
 * includes
 */

#ifndef STLSOFT_INCL_STLSOFT_H_STLSOFT
# include <stlsoft/stlsoft.h>
#endif /* !STLSOFT_INCL_STLSOFT_H_STLSOFT */
#ifdef STLSOFT_TRACE_INCLUDE
# pragma message(__FILE__)
#endif /* STLSOFT_TRACE_INCLUDE */

#ifndef STLSOFT_INCL_STLSOFT_META_HPP_IS_SAME_TYPE
# include <stlsoft/meta/is_same_type.hpp>
#endif /* !STLSOFT_INCL_STLSOFT_META_HPP_IS_SAME_TYPE */
#ifndef STLSOFT_INCL_STLSOFT_META_HPP_SELECT_FIRST_TYPE_IF
# include <stlsoft/meta/select_first_type_if.hpp>
#endif /* !STLSOFT_INCL_STLSOFT_META_HPP_SELECT_FIRST_TYPE_IF */
#ifndef STLSOFT_INCL_STLSOFT_META_HPP_YESNO
# include <stlsoft/meta/yesno.hpp>
#endif /* !STLSOFT_INCL_STLSOFT_META_HPP_YESNO */


/* /////////////////////////////////////////////////////////////////////////
 * namespace
 */

#ifndef STLSOFT_NO_NAMESPACE
namespace stlsoft
{
#endif /* STLSOFT_NO_NAMESPACE */


/* /////////////////////////////////////////////////////////////////////////
 * classes
 */

/** This class is used to create strong types from base types, to facilitate
 * type disambiguation, overloading and mutual incompatibility.
 *
 * \ingroup group__library__Utility
 *
 * For example, the following code creates two types based on the \c int type:
 *
\code
  STLSOFT_GEN_OPAQUE(h_protocol_tt)
  STLSOFT_GEN_OPAQUE(h_port_tt)
  typedef true_typedef<long, h_protocol_tt>  protocol_tt;
  typedef true_typedef<long, h_port_tt>      port_tt;

  protocol_tt pro1(3);    // Ok
  port_tt     prt1(8088); // Ok
  protocol_tt pro2(pro1); // Ok, can copy from another protocol_tt
  port_tt     prt2(pro2); // Error, cannot copy from a protocol_tt
\endcode
 *
 *
 * \tparam T The base type, e.g. \c int, \c std::wstring
 * \tparam U The unique type, usually created by using STLSOFT_GEN_OPAQUE()
 *
 * \remarks U is the unique type, and is usually a type generated by the
 * STLSOFT_GEN_OPAQUE() macro, as in:
\code
  STLSOFT_GEN_OPAQUE(h_uniquelong_tt)
  typedef true_typedef<long, h_uniquelong_tt>     uniquelong_tt;
\endcode
 *
 * thus generating a unique type uniquelong_tt over base-type long.
 */

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
class true_typedef
{
public: // types
    /// The value type
    typedef T                                               value_type;
    /// The unique type
    typedef U                                               unique_type;
    /// The current specialisation of the type
    typedef true_typedef<
        T
    ,   U
    >                                                       class_type;
    /// The reference type
    typedef T&                                              reference;
    /// The non-mutating (const) reference type
    typedef T const&                                        const_reference;

public: // construction
    /// Default constructor
    true_typedef()
        : m_value(value_type())
    {}
    /// Construct from a value type instance
    ss_explicit_k true_typedef(value_type const& value)
        : m_value(value)
    {}
    /// Copy constructor
    true_typedef(class_type const& rhs)
        : m_value(rhs.m_value)
    {}
    /// Copy assignment operator
    class_type const& operator =(class_type const& rhs)
    {
        m_value = rhs.m_value;

        return *this;
    }

public: // accessors
    /// Provides non-mutating (const) access to the base type value
    const_reference base_type_value() const
    {
        return m_value;
    }
    /// Provides mutating access to the base type value
    reference base_type_value()
    {
        return m_value;
    }

private: // fields
    value_type m_value;
};


/* /////////////////////////////////////////////////////////////////////////
 * implementation
 */

#ifndef STLSOFT_DOCUMENTATION_SKIP_SECTION

# if defined(STLSOFT_COMPILER_IS_MSVC) && \
     _MSC_VER >= 1310

#  define STLSOFT_CF_FUNCTION_SIGNATURE_FULL_ARG_QUALIFICATION_REQUIRED_EXCEPT_ARGS_true_typedef
# endif /* compiler */

# if 0 || \
     defined(STLSOFT_CF_FUNCTION_SIGNATURE_FULL_ARG_QUALIFICATION_REQUIRED) || \
     0

#  define STLSOFT_true_typedef_pt_(pt)                      ss_typename_type_ret_k true_typedef<T, U>::pt
# else

#  define STLSOFT_true_typedef_pt_(pt)                      pt
# endif

# if 0 || \
     defined(STLSOFT_CF_FUNCTION_SIGNATURE_FULL_ARG_QUALIFICATION_REQUIRED) || \
     defined(STLSOFT_CF_FUNCTION_SIGNATURE_FULL_ARG_QUALIFICATION_REQUIRED_EXCEPT_ARGS_true_typedef) || \
     0

#  define STLSOFT_true_typedef_rt_(qrt, rrt)                ss_typename_type_k true_typedef<T, U>::qrt
# else

#  define STLSOFT_true_typedef_rt_(qrt, rrt)                rrt
# endif


struct true_typedef_impl_
{
# if __cplusplus >= 201402L

    /// Traits for implementing `operator <<()`, discriminating on whether
    /// `T_lhs` is a true-typedef for shifting or a stream for insertion
    template <
        ss_typename_param_k T_lhs
    ,   ss_typename_param_k T
    ,   ss_typename_param_k U
    >
    struct op_lshift_traits
    {
    public: // types
        /// T.B.C.
        typedef T_lhs                                       lhs_type;
        /// The true type
        typedef true_typedef<T, U>                          tt_type;
    private:
        enum { lhs_is_tt = 0 != is_same_type<lhs_type, tt_type>::value };
    public:
        /// The return-type of the operator
        typedef ss_typename_type_k select_first_type_if<
            lhs_type
        ,   lhs_type&
        ,   lhs_is_tt
        >::type                                             return_type;

    private: // implementation
        /// Implementation for lhs as a true-typedef
        static
        tt_type
        op_lshift_impl(
            T_lhs&              lhs
        ,   tt_type const&      rhs
        ,   yes_type
        )
        {
            return tt_type(lhs.base_type_value() << rhs.base_type_value());
        }

        /// Implementation for lhs as a stream
        static
        T_lhs&
        op_lshift_impl(
            T_lhs&              stm
        ,   tt_type const&      v
        ,   no_type
        )
        {
            stm << v.base_type_value();

            return stm;
        }


    public: // operators
        return_type
        operator ()(
            lhs_type&                   lhs
        ,   true_typedef<T, U> const&   v
        ) const
        {
            typedef ss_typename_type_k value_to_yesno_type<lhs_is_tt>::type is_same_type_yesno_t;

            return op_lshift_impl(
                        lhs
                    ,   v
                    ,   is_same_type_yesno_t()
                    );
        }
    };
# endif /* C++ version */
};
#endif /* !STLSOFT_DOCUMENTATION_SKIP_SECTION */


/* /////////////////////////////////////////////////////////////////////////
 * operators
 */

// Pre-increment

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>&
operator ++(true_typedef<T, U> &v)
{
    ++v.base_type_value();

    return v;
}

// Post-increment

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const
operator ++(true_typedef<T, U> &v, int)
{
    true_typedef<T, U>  r(v);

    v.base_type_value()++;

    return r;
}

// Pre-decrement

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>&
operator --(true_typedef<T, U> &v)
{
    --v.base_type_value();

    return v;
}

// Post-decrement

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const
operator --(true_typedef<T, U> &v, int)
{
    true_typedef<T, U>  r(v);

    v.base_type_value()--;

    return r;
}

// operator ==

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator ==(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return lhs.base_type_value() == rhs.base_type_value();
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator ==(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return lhs.base_type_value() == rhs;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator ==(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return lhs == rhs.base_type_value();
}


// operator !=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator !=(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return ! operator ==(lhs, rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator !=(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return ! operator ==(lhs, rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator !=(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return ! operator ==(lhs, rhs);
}

// operator <

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator <(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return lhs.base_type_value() < rhs.base_type_value();
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator <(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return lhs.base_type_value() < rhs;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator <(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return lhs < rhs.base_type_value();
}

// operator <=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator <=(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return lhs.base_type_value() <= rhs.base_type_value();
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator <=(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return lhs.base_type_value() <= rhs;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator <=(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return lhs <= rhs.base_type_value();
}

// operator >

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator >(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return lhs.base_type_value() > rhs.base_type_value();
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator >(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return lhs.base_type_value() > rhs;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator >(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return lhs > rhs.base_type_value();
}

// operator >=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator >=(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return lhs.base_type_value() >= rhs.base_type_value();
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator >=(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return lhs.base_type_value() >= rhs;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_bool_t
operator >=(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return lhs >= rhs.base_type_value();
}

// operator +

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator +(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() + rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator +(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() + rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator +(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs + rhs.base_type_value());
}

// operator -

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator -(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() - rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator -(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() - rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator -(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs - rhs.base_type_value());
}

// operator *

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator *(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() * rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator *(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() * rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator *(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs * rhs.base_type_value());
}

// operator /

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator /(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() / rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator /(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() / rhs);
}


template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator /(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs / rhs.base_type_value());
}

// operator %

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator %(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() % rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator %(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() % rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator %(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs % rhs.base_type_value());
}

// operator ^

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator ^(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() ^ rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator ^(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() ^ rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator ^(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs ^ rhs.base_type_value());
}

// operator ~

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator ~(true_typedef<T, U> const& v)
{
    return true_typedef<T, U>(~v.base_type_value());
}

// operator <<

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator <<(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() << rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator <<(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() << rhs);
}

#if __cplusplus >= 201402L

/*
template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator <<(
    true_typedef<T, U>&         lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() << rhs.base_type_value());
}
*/

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator <<(
    STLSOFT_true_typedef_pt_(value_type) const  lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs << rhs.base_type_value());
}

/// Left shift operator / stream insertion operator
///
/// \tparam T_lhs The type of the lhs of the expression, which might be a
///   numeric type to be shifted or a stream
template <
    ss_typename_param_k T_lhs
,   ss_typename_param_k T
,   ss_typename_param_k U
>
inline
ss_typename_type_k true_typedef_impl_::op_lshift_traits<T_lhs, T, U>::return_type
operator <<(
    T_lhs&                      lhs
,   true_typedef<T, U> const&   v
)
{
    return true_typedef_impl_::op_lshift_traits<T_lhs, T, U>()(lhs, v);
}
#else /* C++ version ? */

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator <<(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs << rhs.base_type_value());
}
#endif /* C++ version */


// operator >>

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator >>(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() >> rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator >>(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() >> rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator >>(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs >> rhs.base_type_value());
}

// operator &

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator &(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() & rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator &(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() & rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator &(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs & rhs.base_type_value());
}

// operator |

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator |(
    true_typedef<T, U> const&   lhs
,   true_typedef<T, U> const&   rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() | rhs.base_type_value());
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator |(
    true_typedef<T, U> const&                   lhs
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    return true_typedef<T, U>(lhs.base_type_value() | rhs);
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U>
operator |(
    STLSOFT_true_typedef_pt_(value_type) const& lhs
,   true_typedef<T, U> const&                   rhs
)
{
    return true_typedef<T, U>(lhs | rhs.base_type_value());
}

// operator +=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator +=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() += rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator +=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() += rhs.base_type_value();

    return v;
}

// operator -=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator -=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() -= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator -=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() -= rhs.base_type_value();

    return v;
}

// operator *=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator *=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() *= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator *=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() *= rhs.base_type_value();

    return v;
}

// operator /=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator /=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() /= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator /=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() /= rhs.base_type_value();

    return v;
}

// operator %=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator %=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() %= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator %=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() %= rhs.base_type_value();

    return v;
}

// operator ^=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator ^=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() ^= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator ^=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() ^= rhs.base_type_value();

    return v;
}

// operator <<=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator <<=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() <<= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator <<=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() <<= rhs.base_type_value();

    return v;
}

// operator >>=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator >>=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() >>= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator >>=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() >>= rhs.base_type_value();

    return v;
}

// operator &=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator &=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() &= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator &=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() &= rhs.base_type_value();

    return v;
}

// operator |=

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator |=(
    true_typedef<T, U>&                         v
,   STLSOFT_true_typedef_pt_(value_type) const& rhs
)
{
    v.base_type_value() |= rhs;

    return v;
}

template <
    ss_typename_param_k T
,   ss_typename_param_k U
>
inline
true_typedef<T, U> const&
operator |=(
    true_typedef<T, U>&         v
,   true_typedef<T, U> const&   rhs
)
{
    v.base_type_value() |= rhs.base_type_value();

    return v;
}


/* /////////////////////////////////////////////////////////////////////////
 * namespace
 */

#ifndef STLSOFT_NO_NAMESPACE
} /* namespace stlsoft */
#endif /* STLSOFT_NO_NAMESPACE */


/* /////////////////////////////////////////////////////////////////////////
 * inclusion control
 */

#ifdef STLSOFT_CF_PRAGMA_ONCE_SUPPORT
# pragma once
#endif /* STLSOFT_CF_PRAGMA_ONCE_SUPPORT */

#endif /* !STLSOFT_INCL_STLSOFT_UTIL_HPP_TRUE_TYPEDEF */

/* ///////////////////////////// end of file //////////////////////////// */

